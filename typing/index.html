<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Synchronized Typewriter</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh; /* Use min-height for flexibility */
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .status-container {
            width: 80%;
            max-width: 800px;
            display: flex;
            justify-content: space-between; /* Align items */
            align-items: center;
            padding: 10px 15px;
            border: 1px solid #333;
            background-color: rgba(30, 30, 30, 0.8);
            margin-bottom: 20px;
            position: relative; /* Needed for corners if you add them back */
            font-family: monospace;
            font-size: 18px; /* Adjusted size */
        }

         .live-indicator {
            display: flex;
            align-items: center;
        }

        .rec-dot {
            width: 18px; /* Adjusted size */
            height: 18px; /* Adjusted size */
            background-color: red;
            border-radius: 50%;
            margin-right: 10px;
            animation: blink 1s infinite;
        }

        .rec-text {
            font-weight: bold;
            letter-spacing: 1px;
        }

        .time-counter, .progress-info {
             letter-spacing: 1px;
        }

        .typewriter-container {
            width: 80%;
            max-width: 800px;
            height: 60vh; /* Increased height */
            overflow-y: auto;
            background-color: rgba(30, 30, 30, 0.8);
            border: 1px solid #333;
            padding: 20px;
            font-family: "Courier New", Courier, monospace; /* Classic monospace */
            font-size: 16px;
            line-height: 1.6; /* Increased line height */
            position: relative;
            white-space: pre-wrap; /* Preserve whitespace and wrap */
            word-wrap: break-word;
        }

        .text-content {
            position: relative;
            padding-bottom: 30px; /* Space for cursor */
             min-height: 100%; /* Ensure it takes space */
        }

        .text-segment {
            /* Optional: Add styling for loaded segments */
            /* border-top: 1px dashed #444; */
            /* margin-top: 10px; */
            /* padding-top: 10px; */
             display: block; /* Ensure segments stack */
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 1.2em; /* Relative to font size */
            background-color: #eee; /* Brighter cursor */
            vertical-align: text-bottom; /* Align better with text */
            margin-left: 1px;
            animation: blink-cursor 1s infinite steps(1, start); /* Sharper blink */
            box-shadow: 0 0 3px #fff; /* Subtle glow */
        }

        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 18px;
            z-index: 10;
            padding: 20px;
            font-family: monospace;
        }

        .load-more-container {
            text-align: center;
            padding-top: 10px; /* Add padding above button */
        }

        .load-more-button {
            display: inline-block; /* Make it inline */
            padding: 8px 15px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .load-more-button:hover:not(:disabled) {
            background-color: #555;
        }

        .load-more-button:disabled {
            background-color: #222;
            color: #555;
            cursor: not-allowed;
        }

        @keyframes blink {
            50% { opacity: 0.3; }
        }

        @keyframes blink-cursor {
             0%, 100% { opacity: 1; }
             50% { opacity: 0; }
        }

    </style>
</head>
<body>
    <div class="status-container">
         <div class="live-indicator">
             <div class="rec-dot" id="rec-dot"></div>
             <div class="rec-text" id="live-text">LOADING</div>
         </div>
         <div class="progress-info" id="progress-info" style="display: none;">--%</div>
         <div class="day-counter" id="day-counter">YYYY-MM-DD</div>
         <div class="time-counter" id="time-counter">--:--:--.---</div>
    </div>

    <div class="typewriter-container" id="typewriter-container">
        <div class="load-more-container" id="load-more-container" style="display: none;">
            <button class="load-more-button" id="load-more-button">
                Load Previous Text
            </button>
        </div>
        <div class="text-content" id="text-content">
            </div>
         <div class="message-overlay" id="message-overlay">
             Initializing... Please Wait.
         </div>
    </div>

    <script>
        // --- Configuration ---
        const JSON_FILE_PATH = '20250424_044729.json'; // <<< CHANGE THIS TO YOUR JSON FILE
        const DEFAULT_START_TIME_STR = "20250424-190000";  // <<< CHANGE THIS (YYYYMMDD-HHMMSS)
        const FIRST_HOURS = 5;                        // <<< CHANGE THIS
        const LAST_HOURS = 24;                         // <<< CHANGE THIS
        const DEFAULT_HOURS = 19;                      // <<< CHANGE THIS
        const HISTORY_LOAD_CHUNK_SIZE = 1;             // Load 1 full text segment at a time when scrolling up
        // --- End Configuration ---

        // --- Parse URL Parameters ---
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Get start time from URL parameter or use default
        const START_TIME_STR = getUrlParameter('start') || DEFAULT_START_TIME_STR;
        console.log("Using start time:", START_TIME_STR);

        // --- DOM Elements ---
        const typewriterContainer = document.getElementById("typewriter-container");
        const textContentElement = document.getElementById("text-content");
        const progressInfoElement = document.getElementById("progress-info");
        const timeCounterElement = document.getElementById("time-counter");
        const messageOverlay = document.getElementById("message-overlay");
        const loadMoreContainer = document.getElementById("load-more-container");
        const loadMoreButton = document.getElementById("load-more-button");
        const liveTextElement = document.getElementById("live-text");
        const recDotElement = document.getElementById("rec-dot");

        // --- Global State ---
        let textArray = [];
        let textDurations = []; // Duration of each text segment in seconds
        let textCumulativeEndSeconds = []; // Cumulative end time in seconds relative to start
        let totalDurationSeconds = 0;
        let startTime = null; // JS Date object for start time
        let animationFrameId = null;
        let userHasScrolled = false;
        let lastScrollTop = 0;
        let displayStartIndex = 0; // Index of the earliest text segment currently *rendered*
        let currentTargetState = { textIndex: 0, charIndex: 0, isFinished: false };
        let isLive = false; // Flag to track if the display is live or showing history/future
        let lastLogTime = 0; // Track when we last logged info

        // --- Helper Functions ---

        function showMessage(message, isError = false) {
            messageOverlay.textContent = message;
            messageOverlay.style.display = 'flex';
            messageOverlay.style.color = isError ? '#ff8888' : '#ffffff';
            // Hide other elements
            textContentElement.style.display = 'none';
            loadMoreContainer.style.display = 'none';
            liveTextElement.textContent = isError ? "ERROR" : "STATUS";
            recDotElement.style.animation = isError ? 'none' : 'blink 1s infinite';
            recDotElement.style.opacity = isError ? '1' : '1'; // Make dot solid on error
             recDotElement.style.backgroundColor = isError ? 'darkred' : 'red';
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
            textContentElement.style.display = 'block';
             // liveTextElement needs to be updated elsewhere based on state
        }

        function parseStartTime(timeStr) {
            // Format: YYYYMMDD-HHMMSS
            const year = parseInt(timeStr.substring(0, 4), 10);
            const month = parseInt(timeStr.substring(4, 6), 10) - 1; // JS months are 0-indexed
            const day = parseInt(timeStr.substring(6, 8), 10);
            const hour = parseInt(timeStr.substring(9, 11), 10);
            const minute = parseInt(timeStr.substring(11, 13), 10);
            const second = parseInt(timeStr.substring(13, 15), 10);

            // Create date in local timezone instead of UTC
            const date = new Date(year, month, day, hour, minute, second);
            // Quick validation
            if (isNaN(date.getTime()) || date.getFullYear() !== year || date.getMonth() !== month) {
                console.error("Invalid date components:", year, month, day, hour, minute, second);
                throw new Error(`Invalid start time format or date components in: ${timeStr}`);
            }
            return date;
        }

        function calculateTextTimings() {
            if (!textArray || textArray.length === 0) {
                throw new Error("Text array is empty. Cannot calculate timings.");
            }

            textDurations = [];
            textCumulativeEndSeconds = [];
            totalDurationSeconds = 0;
            let cumulativeSeconds = 0;

            for (let i = 0; i < textArray.length; i++) {
                let hours;
                if (textArray.length === 1) {
                    hours = FIRST_HOURS;
                } else if (i === 0) {
                    hours = FIRST_HOURS;
                } else if (i === textArray.length - 1) {
                    hours = LAST_HOURS;
                } else {
                    hours = DEFAULT_HOURS;
                }
                const seconds = hours * 3600;
                textDurations.push(seconds);
                totalDurationSeconds += seconds;
                cumulativeSeconds += seconds;
                textCumulativeEndSeconds.push(cumulativeSeconds);
            }
            console.log("Calculated Durations (s):", textDurations);
            console.log("Calculated Cumulative End Times (s):", textCumulativeEndSeconds);
            console.log("Total Duration (s):", totalDurationSeconds);
        }

        function calculateTargetState(elapsedSeconds) {
            if (textArray.length === 0 || !startTime) {
                return { textIndex: 0, charIndex: 0, isFinished: false };
            }

             const isBeforeStart = elapsedSeconds < 0;
             const isAfterEnd = totalDurationSeconds > 0 && elapsedSeconds >= totalDurationSeconds;

             if (isBeforeStart) {
                return { textIndex: 0, charIndex: 0, isFinished: false, timeStatus: 'before_start' };
             }
              if (isAfterEnd) {
                 const lastIndex = textArray.length - 1;
                return { textIndex: lastIndex, charIndex: textArray[lastIndex].length, isFinished: true, timeStatus: 'after_end' };
             }


            let cumulativeSeconds = 0;
            for (let i = 0; i < textArray.length; i++) {
                const textDuration = textDurations[i];
                const textLength = textArray[i].length;
                const isLastText = (i === textArray.length - 1);
                 const timeAtTextEnd = textCumulativeEndSeconds[i]; // Use precalculated cumulative time

                // Check if the elapsed time falls within this text's duration OR
                // if it's the last text (handle overshoot within the last segment)
                 if (elapsedSeconds <= timeAtTextEnd || isLastText) {
                    let targetCharIndex;
                    if (textDuration <= 0 && textLength > 0) {
                        // If duration is zero or negative, show the whole text immediately
                        targetCharIndex = textLength;
                    } else if (textLength === 0) {
                        targetCharIndex = 0; // No characters in this text
                    } else {
                        const timeAtTextStart = i > 0 ? textCumulativeEndSeconds[i-1] : 0;
                        const timeIntoText = Math.max(0, elapsedSeconds - timeAtTextStart);
                        // Prevent division by zero if text_duration is somehow <= 0 here but length > 0
                        const fraction = textDuration > 0 ? Math.min(1.0, timeIntoText / textDuration) : 1.0;
                        targetCharIndex = Math.floor(textLength * fraction); // Use floor to get index before target char
                        // Ensure index is within bounds [0, text_length]
                        targetCharIndex = Math.max(0, Math.min(textLength, targetCharIndex));
                    }
                     return { textIndex: i, charIndex: targetCharIndex, isFinished: false, timeStatus: 'in_progress' };
                }
                // Cumulative seconds logic handled by checking textCumulativeEndSeconds[i]
            }

            // Fallback (should theoretically not be reached if isAfterEnd check is correct)
            const lastIndex = textArray.length - 1;
            return { textIndex: lastIndex, charIndex: textArray[lastIndex].length, isFinished: true, timeStatus: 'after_end' };
        }

        // --- Main Update and Rendering ---

        function updateDisplay() {
            const currentTime = Date.now();
            if (!startTime || textArray.length === 0) {
                animationFrameId = requestAnimationFrame(updateDisplay); // Keep checking
                return; // Not initialized yet
            }

            const elapsedSeconds = (currentTime - startTime.getTime()) / 1000;
            currentTargetState = calculateTargetState(elapsedSeconds);

            // Log information every 10 seconds
            if (currentTime - lastLogTime >= 10000) {
                logCurrentState(elapsedSeconds);
                lastLogTime = currentTime;
            }

             // Update Live/Status Indicator
             switch(currentTargetState.timeStatus) {
                case 'before_start':
                    liveTextElement.textContent = "WAITING";
                    recDotElement.style.animation = 'none';
                    recDotElement.style.opacity = '0.5';
                    isLive = false;
                    break;
                case 'after_end':
                     liveTextElement.textContent = "FINISHED";
                     recDotElement.style.animation = 'none';
                     recDotElement.style.opacity = '1';
                     recDotElement.style.backgroundColor = 'darkgrey';
                     isLive = false;
                    break;
                 case 'in_progress':
                 default:
                     liveTextElement.textContent = "LIVE";
                     recDotElement.style.animation = 'blink 1s infinite';
                     recDotElement.style.backgroundColor = 'red';
                     recDotElement.style.opacity = '1';
                     isLive = userHasScrolled ? false : true; // Live only if at the bottom
                     break;
             }


            // Determine the full text to render
            let fullVisibleText = "";
            for (let i = displayStartIndex; i < currentTargetState.textIndex; i++) {
                 // Add explicit paragraph breaks between segments if desired
                 // fullVisibleText += textArray[i] + "\n\n---\n\n";
                fullVisibleText += textArray[i];
            }
            // Add the current segment up to the target character
            if (currentTargetState.textIndex >= displayStartIndex && currentTargetState.textIndex < textArray.length) {
                 fullVisibleText += textArray[currentTargetState.textIndex].substring(0, currentTargetState.charIndex);
            } else if (currentTargetState.isFinished && displayStartIndex <= currentTargetState.textIndex) {
                // If finished, make sure the last segment is fully displayed if it was loaded
                 fullVisibleText += textArray[currentTargetState.textIndex];
            }


            // Update DOM - Clear previous content and add new
            textContentElement.innerHTML = ''; // Clear previous content efficiently

             // Split the full text by segment index for potential styling/structure
             let segmentStartIndex = 0;
             for (let i = displayStartIndex; i < textArray.length; i++) {
                 const segmentText = textArray[i];
                 let segmentToShow = "";

                 if (i < currentTargetState.textIndex) {
                     segmentToShow = segmentText;
                 } else if (i === currentTargetState.textIndex) {
                     segmentToShow = segmentText.substring(0, currentTargetState.charIndex);
                 } else if (currentTargetState.isFinished && i === currentTargetState.textIndex) {
                     // If animation finished, show the full last segment
                     segmentToShow = segmentText;
                 } else {
                     break; // Don't render future segments
                 }

                 if (segmentToShow) {
                    const span = document.createElement('span');
                    span.className = 'text-segment'; // Add class for potential styling
                    span.textContent = segmentToShow;
                    textContentElement.appendChild(span);
                 }

                // Add paragraph breaks if needed (visual separation)
                // const breakEl = document.createElement('hr');
                // textContentElement.appendChild(breakEl);
             }


            // Add cursor if animation is not finished
            if (!currentTargetState.isFinished) {
                const cursorSpan = document.createElement('span');
                cursorSpan.className = 'cursor';
                textContentElement.appendChild(cursorSpan); // Append cursor at the very end
            }

            // Auto-scroll if live and not manually scrolled
            if (isLive && !userHasScrolled) {
                typewriterContainer.scrollTop = typewriterContainer.scrollHeight;
            }

            // Update progress percentage
             const progressPercent = totalDurationSeconds > 0
                 ? Math.min(100, (elapsedSeconds / totalDurationSeconds) * 100)
                 : (currentTargetState.isFinished ? 100 : 0);
             progressInfoElement.textContent = `${progressPercent.toFixed(2)}%`;

            // Schedule next frame
            animationFrameId = requestAnimationFrame(updateDisplay);
        }

        function loadPreviousSegment() {
             if (displayStartIndex <= 0) return; // Already at the beginning

             displayStartIndex--;
             loadMoreButton.disabled = true;
             loadMoreButton.textContent = 'Loading...';

            // --- Prepend the new text segment ---
            const segmentText = textArray[displayStartIndex];
             const segmentSpan = document.createElement('span');
             segmentSpan.className = 'text-segment';
             segmentSpan.textContent = segmentText; // Ensure newlines are preserved

            // --- Manage Scroll Position ---
             const oldScrollHeight = textContentElement.scrollHeight;
             const oldScrollTop = typewriterContainer.scrollTop;

            // Prepend the new segment
             textContentElement.prepend(segmentSpan);
             // Optional: Add a visual separator
             // const separator = document.createElement('hr');
             // separator.style.margin = '1em 0';
             // textContentElement.prepend(separator);


            // Adjust scroll position to keep the view relatively stable
             const newScrollHeight = textContentElement.scrollHeight;
             typewriterContainer.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
             lastScrollTop = typewriterContainer.scrollTop; // Update last scroll position


             // --- Update Button State ---
             loadMoreButton.disabled = (displayStartIndex <= 0);
             loadMoreButton.textContent = (displayStartIndex <= 0) ? 'Beginning Reached' : 'Load Previous Text';
             userHasScrolled = true; // Loading previous means user is looking at history
             isLive = false; // No longer live tracking the end
             liveTextElement.textContent = "HISTORY"; // Indicate viewing history

        }

        // --- Initialization ---

        async function loadAndInitialize() {
            try {
                showMessage("Loading text data...");
                const response = await fetch(JSON_FILE_PATH);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} - Could not fetch ${JSON_FILE_PATH}`);
                }
                textArray = await response.json();

                if (!Array.isArray(textArray) || textArray.length === 0 || textArray.some(item => typeof item !== 'string')) {
                     throw new Error("Invalid JSON format. Expected an array of strings.");
                 }

                showMessage("Parsing start time...");
                startTime = parseStartTime(START_TIME_STR);
                console.log("Parsed Start Time:", startTime.toISOString());

                showMessage("Calculating timings...");
                calculateTextTimings();

                // --- Determine Initial State ---
                 const initialElapsed = (Date.now() - startTime.getTime()) / 1000;
                 const initialState = calculateTargetState(initialElapsed);
                 displayStartIndex = initialState.textIndex; // Start rendering from the current segment

                 // Optionally load some immediate history for context
                 const historyToLoad = 1; // Load 1 segment before the current one initially
                 if (initialState.textIndex > 0) {
                      displayStartIndex = Math.max(0, initialState.textIndex - historyToLoad);
                 }

                console.log("Initial Target State:", initialState);
                 console.log("Initial Display Start Index:", displayStartIndex);

                 hideMessage(); // Hide loading message

                 // Show and enable the load more button if not starting at the very beginning
                 if (displayStartIndex > 0) {
                     loadMoreContainer.style.display = 'block';
                     loadMoreButton.disabled = false;
                     loadMoreButton.textContent = 'Load Previous Text';
                 } else {
                     loadMoreContainer.style.display = 'block'; // Show it even if disabled initially
                     loadMoreButton.disabled = true;
                     loadMoreButton.textContent = initialElapsed > 0 ? 'Beginning Reached' : 'Waiting...';
                 }

                // Initial display update and start animation loop
                updateDisplay(); // First render
                 requestAnimationFrame(updateTimeCounter); // Start time counter loop


            } catch (error) {
                console.error("Initialization failed:", error);
                showMessage(`Error: ${error.message}. Please check console and configuration.`, true);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
            }
        }

        // --- Event Listeners ---

        typewriterContainer.addEventListener("scroll", () => {
             const currentScrollTop = typewriterContainer.scrollTop;
             const scrollBottom = typewriterContainer.scrollHeight - typewriterContainer.clientHeight;

             // Detect if user scrolled up significantly
             if (currentScrollTop < lastScrollTop - 10) { // Threshold to avoid minor jitter detection
                 userHasScrolled = true;
                isLive = false; // No longer live tracking the end
                 if (currentTargetState.timeStatus === 'in_progress') {
                     liveTextElement.textContent = "HISTORY"; // Indicate viewing history
                 }
             } else if (currentScrollTop >= scrollBottom - 10) { // Near the bottom
                 userHasScrolled = false;
                 // isLive will be set correctly in updateDisplay based on timeStatus
                 if (currentTargetState.timeStatus === 'in_progress') {
                     liveTextElement.textContent = "LIVE";
                 }
             }
             lastScrollTop = currentScrollTop;
        });

        loadMoreButton.addEventListener('click', loadPreviousSegment);

        document.addEventListener("visibilitychange", () => {
             if (document.visibilityState === "visible") {
                 console.log("Tab became visible, forcing state update.");
                 // No need to explicitly catch up, updateDisplay handles it based on time
                 if (animationFrameId === null && startTime) { // Restart loop if stopped
                     updateDisplay();
                 }
             } else {
                 console.log("Tab became hidden.");
                 // Optional: Could cancelAnimationFrame here and restart on visible
                 // cancelAnimationFrame(animationFrameId);
                 // animationFrameId = null;
             }
         });

        // --- Real-time Counter ---
        function updateTimeCounter() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, "0");
            const minutes = String(now.getMinutes()).padStart(2, "0");
            const seconds = String(now.getSeconds()).padStart(2, "0");
            const milliseconds = String(now.getMilliseconds()).padStart(3, "0");
            timeCounterElement.textContent = `${hours}:${minutes}:${seconds}.${milliseconds}`;

            // Update day counter with current date in YYYY-MM-DD format
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, "0"); // Months are 0-indexed
            const day = String(now.getDate()).padStart(2, "0");
            document.getElementById("day-counter").textContent = `${year}-${month}-${day}`;

            requestAnimationFrame(updateTimeCounter); // Continue the loop
        }

        // --- Logging Function ---
        function logCurrentState(elapsedSeconds) {
            if (!startTime || textArray.length === 0 || !currentTargetState) return;

            // Calculate time difference from start time
            const days = Math.floor(elapsedSeconds / 86400);
            const hours = Math.floor((elapsedSeconds % 86400) / 3600);
            const minutes = Math.floor((elapsedSeconds % 3600) / 60);
            const seconds = Math.floor(elapsedSeconds % 60);

            // Current time
            const now = new Date();
            const timeStr = now.toISOString();

            // Cursor position info
            const textIndex = currentTargetState.textIndex;
            const charIndex = currentTargetState.charIndex;

            // Calculate absolute character position
            let absoluteCharPosition = charIndex;
            for (let i = 0; i < textIndex; i++) {
                absoluteCharPosition += textArray[i].length;
            }

            // Get context around cursor
            let contextBefore = "";
            let contextAfter = "";

            if (textIndex < textArray.length) {
                const currentText = textArray[textIndex];
                const contextSize = 20; // Characters to show before/after cursor

                const startPos = Math.max(0, charIndex - contextSize);
                const endPos = Math.min(currentText.length, charIndex + contextSize);

                contextBefore = currentText.substring(startPos, charIndex).replace(/\n/g, '/');
                contextAfter = currentText.substring(charIndex, endPos).replace(/\n/g, '/');
            }

            // Log the information
            console.log(`
=== LOG UPDATE (${timeStr}) ===
Time since start: ${days}d ${hours}h ${minutes}m ${seconds}s (${elapsedSeconds.toFixed(2)}s)
Cursor position: Text #${textIndex}/${textArray.length}, Char ${charIndex}/${textArray[textIndex]?.length || 0} (${(100*charIndex/(textArray[textIndex]?.length || 1)).toFixed(2)}%)
Overall: Char ${absoluteCharPosition}/${textArray.reduce((acc, curr) => acc + curr.length, 0)} (${(100*absoluteCharPosition/(textArray.reduce((acc, curr) => acc + curr.length, 0))).toFixed(2)}%)
Context around target: "...${contextBefore}<-CURSOR->${contextAfter}..."
Display state: ${isLive ? 'LIVE' : 'HISTORY'}, User scrolled: ${userHasScrolled}
Progress: ${(elapsedSeconds / totalDurationSeconds * 100).toFixed(2)}%
=== END LOG ===
`);
        }

        // --- Start Everything ---
        loadAndInitialize();

    </script>
</body>
</html>